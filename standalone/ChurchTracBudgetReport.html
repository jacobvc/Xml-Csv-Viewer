<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    // Title and revision
    var title = 'ChurchTrac Budget Report Tool'
    var revision = '1.8';

    var revisionstring = title + ', Revision ' + revision + ", 10/2024";

    // String constants for spelling consistency
    var combinedName = 'combined';
    var currentBudgetName = '* Current Budget';
    var currentActualName = '* Current Actual';
    var currentDifferenceName = '* Current Difference';
    var ytdBudgetName = 'YTD Budget';
    var ytdActualName = 'YTD Actual';
    var ytdDiffrenceName = 'YTD Difference';

    // Highlight groups - Arrays of [budget column, actual column, related columns ..]
    var highlightGroups = [
      [currentBudgetName, currentActualName, currentDifferenceName],
      [ytdBudgetName, ytdActualName, ytdDiffrenceName]
    ];

    var pageheadingSettings = 'pageheadingSettings';

    // Name of selected content
    var thisContent = '';
    var priorContent = '';
    var rowOrder = [];

    // Data from the file as named array objects.
    let fileData = {};

    /* Column names in selected content */
    let contentColumns = [];

    // File reader
    var reader = new FileReader();
    var rowreader = new FileReader();

    function readRowOrder(id) {
      let input = document.getElementById(id);
      var currentFile = input.files[0];
      rowreader.readAsText(currentFile);

      rowreader.onload = function () {
        //rowOrder = JSON.parse(rowreader.result);
        rowOrder = [];
        lines = rowreader.result.split(/\r?\n/);

        lines.forEach(function (line) {
          rowOrder.push(line.trim());
        });
      };
      rowreader.onerror = function () {
        console.log(rowreader.error);
      };
    }

    function readFile(id, prior) {
      let input = document.getElementById(id);
      var currentFile = input.files[0];
      reader.readAsText(currentFile);

      reader.onload = function () {
        processCsv(currentFile.name, reader.result, prior);
      };
      reader.onerror = function () {
        console.log(reader.error);
      };
    }

    // Processing input data
    function processCsv(filename, content, prior) {
      hideDataTable();
      if (filename.toLowerCase().endsWith(".csv")) {
        let contentName = decamelize(filename.replace(/\.[^/.]+$/, ""));
        let data;
        data = d3.csvParse(content);
        if ('Category' in data[0]) {
          while (data[data.length - 1].Category.length == 0) {
            // Remove any empty last rows
            data.splice(data.length - 1, 1);
          }
        }
        fileData[contentName] = data;

        if (prior) {
          priorContent = contentName;
          contentName = combinedName
        }
        else {
          thisContent = contentName;

          let list1 = [];
          list1.push({ 'name': 'Category', 'text': 'Category' });
          createColumnList(contentName, Object.keys(data[0]), list1);

          let list = [];
          list.push({ 'name': 'Category', 'text': 'Category' });
          list.push({ 'name': currentBudgetName, 'text': currentBudgetName });
          list.push({ 'name': currentActualName, 'text': currentActualName });
          list.push({ 'name': currentDifferenceName, 'text': currentDifferenceName });
          createColumnList(combinedName, Object.keys(data[0]), list);

          let objectElem = document.getElementById("id-object");
          objectElem.textContent = " - " + contentName;
          if (priorContent) {
            contentName = combinedName;
          }
        }
        populateColumnOptions(contentName);
      }
      else {
        alert("File must be 'csv'");
      }
    }

    function createColumnList(name, columns, list) {
      columns.forEach(function (column) {
        if (column != 'Category') {
          list.push({ 'name': column, 'text': column });
        }
      });
      contentColumns[name] = list;
    }

    // Options
    function populateFormatOptions(elemId) {
      var formElem = document.getElementById(elemId);
      populateOptions(formElem, tableOptions, 'fmt-', false, [sorting]);
      overrideOptions(tableOptions, 'fmt-');
    }
    function getFormatOptions() {
      return getOptions(tableOptions, 'fmt-');
    }
    function populateColumnOptions(which, elemId) {
      hideDataTable();

      var formElem = document.getElementById('id-columns');
      populateOptions(formElem, contentColumns[which], 'col-', true);
      overrideOptions(contentColumns[which], 'col-');
    }
    function getColumnOptions(which) {
      return getOptions(contentColumns[which], 'col-');
    }

    function newDataElement(columns, category) {
      var obj = {};
      for (column in columns) {
        obj[column] = "";
      }
      obj['Category'] = category;
      return obj;
    }

    // Creating and displaying the table

    // Hide 'elemId' and go to print dialog, then unhide upon return
    function printHiding(elemId) {
      var elem = document.getElementById(elemId);
      elem.style = "display: none";
      print();
      elem.style = "display: block";
    }

    /* Process current and prior reports and generate a combined version
     * that includes current plus current actual and budget columns that
     * contain the difference between prior and current
     */
    function combine() {
      var current = fileData[thisContent];
      var prior = fileData[priorContent];
      var combined = [];
      if (current.length == prior.length) {
        for (var i = 0; i < current.length; ++i) {
          combined[i] = current[i];
          var result = columnSubtract(current[i][ytdActualName], prior[i][ytdActualName]);
          combined[i][currentActualName] = result.value;
          result = columnSubtract(current[i][ytdBudgetName], prior[i][ytdBudgetName]);
          combined[i][currentBudgetName] = result.value;
          result = columnSubtract(current[i][currentActualName], current[i][currentBudgetName]);
          combined[i][currentDifferenceName] = result.value;

        }
        fileData[combinedName] = combined;
        return true;
      }
      else {
        return false;
      }
    }

    // Change the order of rows in current to match rowOrder
    function reorder(columns, current) {
      var added = 0;
      var prefix = "";

      var reordered = [];

      if (rowOrder.length > 0) {
        // There is a reorder spec
        if (rowOrder.length >= current.length) {
          // And it has the correct number of rows
          for (var r = 0; r < rowOrder.length; ++r) {
            var found = false;
            for (var i = r - added; i < current.length; ++i) {
              // reorder to match
              if (current[i]['Category'].replace(/ /g, '') == rowOrder[r].replace(/ /g, '')) {
                let tmp = current[i];
                if (rowOrder[r].toUpperCase().startsWith(incomeCategories.toUpperCase())
                  || rowOrder[r].toUpperCase().startsWith(expenseCategories.toUpperCase())) {
                  prefix = "";
                }
                reordered[r] = JSON.parse(JSON.stringify(current[i]));
                reordered[r]['Category'] = prefix + current[i]['Category'];
                current[i] = current[r - added];
                current[r - added] = tmp;
                found = true;
                break;
              }
            }
            if (!found) {
              reordered[r] = newDataElement(columns, rowOrder[r]);
              prefix = rowOrder[r] + ': ';
              console.log("Adding row " + rowOrder[r]);
              ++added;
              //throw new Error("Budget Row Order Column '" + rowOrder[r] + "' not found");
            }
          }
          if (rowOrder.length != current.length + added) {
            throw new Error("Budget Row Order does not contain all rows");
          }
        }
        else {
          throw new Error("Budget Row Order contains too few rows");
        }
        return reordered;
      }
      else {
        return current;
      }
    }

    // Render the budget table
    function showData() {
      let elem = document.getElementById('id-data');
      let format = getFormatOptions();
      let columns = getColumnOptions(thisContent)
      let onclick = null; // detailForm;
      let noCsvHeader = false;

      let err = document.getElementById('id-error');
      err.innerText = "";
      hideDataform();

      elem.replaceChildren();

      if (thisContent) {
        try {
          decimalPlaces = document.getElementById('decimal-places').value;
          var dodate = document.getElementById('printed-on');

          var pageheadingInpElem = document.getElementById('pageheading');
          if (pageheadingInpElem.value.trim().length > 0) {
            var span = document.createElement("span");
            span.style = "display:flex";
            var pageheadingElem = document.createElement('h3');
            pageheadingElem.textContent = pageheadingInpElem.value.trim();
            span.appendChild(pageheadingElem);
            if (dodate.checked) {
              var printed = document.createElement('h3');
              printed.textContent = "Printed on " + new Date().toLocaleDateString();
              printed.style = "margin-left: auto; display: inline-block";
              span.appendChild(printed);
            }
            elem.appendChild(span);
          }

          if (priorContent) {
            columns = getColumnOptions(combinedName);
            combine();

            createTable(reorder(columns, fileData[combinedName]), elem, thisContent, columns,
              noCsvHeader, onclick, highlightGroups, format);
            var footer = document.createElement('h4');
            if (currentActualName in columns || currentBudgetName in columns || currentDifferenceName in columns) {
              footer.textContent = '* "Current" covers the interval from '
                + priorContent + " to " + thisContent;
              footer.style = "display: inline-block";
              elem.appendChild(footer);
            }
          }
          else {
            createTable(reorder(columns, fileData[thisContent]), elem, thisContent, columns,
              noCsvHeader, onclick, highlightGroups, format);
          }
          var span = document.createElement("span");
          span.style = "float:right;";
          span.textContent = "Created by " + revisionstring;
          elem.appendChild(span);

          localStorage.setItem(pageheadingSettings, pageheadingInpElem.value.trim());
          localStorage.setItem('printdate', JSON.stringify(dodate.checked));
          localStorage.setItem('decimalPlaces', JSON.stringify(decimalPlaces));
        } catch (error) {
          err.textContent = 'Rendering error: ' + error.message;
        }
      }
      else {
        err.textContent = '"This Month" file not loaded';
      }
      showDataTable();
    };

    // Event handler (if onclick is specified in showData)
    function detailForm(src) {
      var formElem = document.getElementById("dataFormId");
      populateForm(src, thisContent, formElem);
      showDataform();
    }

    // Make a popup with a textarea containing the category value
    // of each row, one per line
    function CreateRowList() {
      if (thisContent) {
        var current = fileData[thisContent];
        if (priorContent && fileData[combinedName]) {
          current = fileData[combinedName]
        }
        files = [];
        for (var i = 0; i < current.length; ++i) {
          files.push(current[i]['Category']);
        }
        const file = new File(files, 'output.txt', { type: "text/plain" });
      }
      else {
        alert("No content loaded");
      }
    }

    function showRowOrder() {
      if (thisContent) {
        // Content is available to process
        var current = fileData[thisContent];
        if (priorContent && fileData[combinedName]) {
          // There is combined content. Use that instead
          current = fileData[combinedName]
        }
        // Get the HTML element and create title / instructions
        var name = "rowOrder"
        var elem = document.getElementById("dataFormId");
        elem.replaceChildren();
        var titleElem = document.createElement('h2');
        titleElem.textContent = "Budget Row Order";
        elem.appendChild(titleElem);

        var instructions = document.createElement('p');
        instructions.textContent
          = 'This is the current row order. It may change if you "Choose File"'
          + 'a Row Order file and "(re)Display\n\n'
          + 'You can copy this list and save it to a text file to create a new Row Order file, then reorder those contents as desired';
        elem.appendChild(instructions);

        // Fill value with the categories
        var value = '';
        for (var i = 0; i < current.length; ++i) {
          value += current[i]['Category'] + '\n';
        }

        // Create a textarea and fill it with value
        var inputElem = document.createElement('textarea');
        inputElem.id = name;
        inputElem.name = name;
        inputElem.value = value;

        elem.appendChild(inputElem);

        showDataform();
      }
      else {
        alert("No content loaded");
      }
    }

    // Visibility
    function showDataform() {
      document.getElementById("id-data-form").style.display = "block";
    }
    function hideDataform() {
      document.getElementById("id-data-form").style.display = "none";
    }

    function showDataTable() {
      document.getElementById("id-data").style.display = "block";
    }
    function hideDataTable() {
      hideDataform();
      document.getElementById("id-data").style.display = "none";
    }

    // Form Load
    document.addEventListener('DOMContentLoaded', function () {
      hideDataform();
      populateFormatOptions('id-format');
      var elem = document.getElementById('pageheading');
      elem.value = localStorage.getItem(pageheadingSettings);

      elem = document.getElementById('printed-on');
      elem.checked = JSON.parse(localStorage.getItem('printdate'));

      elem = document.getElementById('decimal-places');
      elem.value = JSON.parse(localStorage.getItem('decimalPlaces'));

      elem = document.getElementById('title');
      elem.innerHTML = title;

      elem = document.getElementById('revision');
      elem.innerText = revisionstring;
    });

"use strict";
/*  Present and query a set of options with selection checkboxes 

Required tooltip html support:
  Utilizes a single id="tooltip-text" element for entire page)
    Example:
      <p id="tooltip-text">The tooltip text.</p>

Required containerElem div of class container in html:
  Example (Note - group DIV is optional):
    <div class="group">Option Label
        <div id="<Container element ID>" class="container"></div>
    </div>

Required CSS elements:
    p#tooltip-text, .container, .contained, (optional) .group
*/

/* Populate 'containerElem' with options from 'list' using 'scope' to qualify
   element ID's, and initializing state to 'isChecked'; excluding 'exclude' 
   list members. When an event handler is provided, it is connected to the 
   checkboxes

   'list' is an array of objects containing 'name', 'text', and optional 'description'.
   If description is present, it is used for tooltip text.

   If optional 'choices' are specified, render selecable list of choices,
   otherwise render checkbox.

   Note that scope + name are transformed into valid HTML ID's
 */
function populateOptions(containerElem, list, scope, isChecked, exclude = [],  eventHandler = null) {
  containerElem.replaceChildren();
  if (list) {
    const tooltip = document.getElementById("tooltip-text");
    list.forEach(function (item) {
      if (exclude.indexOf(item.name) < 0) {
        let idPart = _createHtmlId(scope + item.name);

        var divElem = document.createElement('div');
        divElem.id = "iddiv-" + idPart;
        divElem.className = "contained";

        if ('choices' in item) {
          var labelElem = document.createElement('label');
          labelElem.textContent = item.text + '\n';
          divElem.appendChild(labelElem);

          var choiceNone = 'N/A';
          if ('choiceNone' in item) {
            choiceNone = item.choiceNone;
          }

          var elements = CreateRadioButton('id-' + idPart, choiceNone, "");
          elements[0].checked = true;
          var div = document.createElement('div');
          div.appendChild(elements[0]);
          div.appendChild(elements[1]);
          divElem.append(div);

          //var anyChecked;
          item.choices.forEach(function (choice) {
            elements = CreateRadioButton('id-' + idPart, choice, choice);

            div = document.createElement('div');
            div.appendChild(elements[0]);
            div.appendChild(elements[1]);
            divElem.append(div);
          });
        }
        else {
          var inputElem = document.createElement('input');
          inputElem.type = 'checkbox';
          inputElem.id = 'id-' + idPart;
          inputElem.name = item.name;
          inputElem.value = item.name;
          inputElem.checked = isChecked;

          var labelElem = document.createElement('label');
          labelElem.htmlFor = 'id-' + idPart;
          labelElem.textContent = item.text + '\n';

          divElem.appendChild(inputElem);
          divElem.appendChild(labelElem);

          if (eventHandler) {
            inputElem.addEventListener("change", eventHandler);
          }
        }

        containerElem.appendChild(divElem);
      }
    });
    list.forEach(function (item) {
      if (exclude.indexOf(item.name) < 0) {
        let idPart = _createHtmlId(scope + item.name);
        if (item.description) {
          document.getElementById("iddiv-" + idPart).addEventListener('mouseenter', (event) => {
            tooltip.style.display = 'block';
            tooltip.textContent = item.description;
            tooltip.style.top = (event.target.offsetTop - 60) + 'px';
            tooltip.style.left = (event.target.offsetLeft
              + (event.target.clientWidth - tooltip.clientWidth) / 2) + 'px';
          }, false);

          // change display to 'none' on mouseleave
          document.getElementById("iddiv-" + idPart).addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
          }, false);
        }
      }
    });
  }
}

/*
  Helper function - Create a radio button in group 'groupId' for 'choice'
  with 'value'.
 */
function CreateRadioButton(groupId, choice, value) {
  var inputElem = document.createElement('input');
  inputElem.type = 'radio';
  inputElem.id = groupId + choice;
  inputElem.name = groupId;  
  inputElem.value = value;

  var labelElem = document.createElement('label');
  labelElem.htmlFor = groupId + choice;
  labelElem.textContent = choice;

  return [inputElem, labelElem];
}

/* Get selected options of 'scope' in 'list' as an object with a field for
 * each chosen list item.
 *
 * The value is the text of the selected option (empty string if options 
 * not present and box checked)
 *
 * Save current option settings to localStorage
 */
function getOptions(list, scope) {
  let checked = {};
  if (list) {
    list.forEach(function (item) {
      let idPart = _createHtmlId(scope + item.name);
      var elem = document.getElementById('id-' + idPart);
      if (elem && elem.checked) {
        checked[elem.name] = "";
      }
      else if ('choices' in item) {
        var value;
        let name = 'id-' + _createHtmlId(scope + item.name);
        var btns = document.getElementsByName(name);
        btns.forEach(function (obj) {
          if (obj.checked) {
            value = obj.value;
          }
        });
        if (value) {
          checked[item.name] = value;
        }
      }
    });
  }
  localStorage.setItem(scope + 'settings', JSON.stringify(checked));

  return checked;
}

/* Override displayed values from values previously saved in localStorage
 */
function overrideOptions(list, scope) {
  var checked = JSON.parse(localStorage.getItem(scope + 'settings'));
  if (list && checked) {
    list.forEach(function (item) {
      let idPart = _createHtmlId(scope + item.name);
      var elem = document.getElementById('id-' + idPart);
      if (elem) {
        elem.checked = (elem.name in checked);
      }
      else if ('choices' in item) {
          let name = 'id-' + _createHtmlId(scope + item.name);
          var btns = document.getElementsByName(name);
          btns.forEach(function (obj) {
            if (checked.choices == obj.value) {
              obj.checked = true;
            }
          });
        }
      
    });
  }
}

/* Override checked state of all non-choice items of 'scope' in 'list' to 
 * 'isChecked'
 */
function setAllOptions(list, scope, isChecked) {
  if (list) {
    list.forEach(function (item) {
      let idPart = _createHtmlId(scope + item.name);
      var elem = document.getElementById('id-' + idPart);
      if (elem) {
        elem.checked = isChecked;
      }
    });
  }
}

/* Utility function to create properly formed ID */
function _createHtmlId(value) {
  const id = value ? value.replace(/\W/g, '_') : '_';
  return id.charAt(0).match(/[\d_]/g)?.length ? `id_${id}` : id;
}"use strict";
// variables containing 'name's
let nested = "Nested";
let incomeExpense = "Income-Expense";
let subtotal = "Subtotal";
let blankZeros = "Blank-Zeros";
let sorting = "sorting";
let highlight = "highlight";

let tableOptions = [
  {
    'name': incomeExpense, 'text': 'Indent inside Income/Expense rows',
    'description': 'Ident all rows that do not start with "Income Category" or "Expense Category"'
  },
  {
    'name': nested, 'text': 'Indent ":" separated categories',
    'description': 'Indent colon separated category names as a hierarchy'
  },
  {
    'name': subtotal, 'text': 'Append Subtotals', 'description':
      'Append subtotal rows (to indented numeric columns)'
  },
  {
    'name': blankZeros, 'text': 'Blank zero values',
    'description': 'Do not display values that are "0"'
  },
  {
    'name': sorting, 'text': 'Sort columns', 'description':
      'Enable sorting by clicking column heading'
  },
  {
    'name': highlight, 'text': 'Highlight Concerns', 'description':
      'Highlight under-budget income and over-budget expenses'
  },
  /*
  {
    'name': 'choices', 'text': 'Choices test', 'description':
      'Test for choices implementation', 
      'choices': ['A', 'B', 'C'], 'choiceNone' : 'None'
  },
  */
];

let incomeCategories = "INCOME CATEGORIES";
let expenseCategories = "EXPENSE CATEGORIES";

let doingExpense = false;
let decimalPlaces = 2;


/*

    UTILITY

*/
function getJsonColumns(item) {
  var columns = [];
  for (var name in item) {
    if (name !== '@attributes') {
      columns.push(name);
    }
  }
  return columns;
}

function getJsonColumnNames(item) {
  var columns = [];
  for (var name in item) {
    if (name !== '@attributes') {
      columns[name] = name;
    }
  }
  return columns;
}


function decamelize(name) {
  var out = name.substr(0, 1).toUpperCase();
  for (var i = 1; i < name.length; ++i) {
    if (name[i] == name[i].toUpperCase()) {
      if (i + 1 < name.length && name[i + 1] != name[i + 1].toUpperCase())
        out += " ";
    }
    out += name[i];
  }
  return out;
}

function indentStyle(steps) {
  return (steps * 15) + 'px';
}

/*

    FORM

*/
function populateForm(item, title, elem) {
  elem.replaceChildren();
  var titleElem = document.createElement('h2');
  titleElem.textContent = title;
  elem.appendChild(titleElem);

  var columns = getJsonColumns(item);
  var count = 0;
  columns.forEach(function (name) {
    if (typeof (item[name]) === 'object') {
      var labelElem = document.createElement('label');
      labelElem.htmlFor = name;
      labelElem.textContent = decamelize(name);
      elem.appendChild(labelElem);
      createOnlyTable(item[name][Object.keys(item[name])[0]], elem, [], false, detailForm, []);
    }
    else {
      addFormField(elem, name, decamelize(name), item[name]);
    }
    if ((count++ & 1) == 1) {
      elem.appendChild(document.createElement("br"));
    }
  });
}
function addFormField(elem, name, label, value) {
  var date = new Date(value)
  if (date.getTime() === date.getTime() && value.indexOf('-') > 0) {
    if (date.getFullYear() > 1) {
      value = date.toDateString();
    }
    else {
      value = '';
    }
  }

  var labelElem = document.createElement('label');
  labelElem.htmlFor = name;
  labelElem.textContent = label;

  var inputElem = document.createElement('input');
  inputElem.type = 'text';
  inputElem.id = name;
  inputElem.name = name;
  inputElem.value = value;
  inputElem.size = 20;

  elem.appendChild(labelElem);
  elem.appendChild(inputElem);
}

/*

    TABLE

*/
function createTable(data, elem, title, columns, noHeader, showDetail, highlightGroups, options) {
  if (data.length == 1) {
    if (showDetail) {
      showDetail(data[0]);
    }
    else {
      populateForm(data[0], title, elem);
    }
    return;
  }
  var titleElem = document.createElement('h3');
  titleElem.textContent = title;
  elem.appendChild(titleElem);
  createOnlyTable(data, elem, columns, noHeader, showDetail, highlightGroups, options)
}
function createOnlyTable(data, elem, columns, noHeader, showDetail, highlightGroups, options) {
  var table = document.createElement('table');
  elem.appendChild(table);
  if (columns.length == 0 && data.length > 0) {
    columns = getJsonColumnNames(data[0]);
  }
  if (!noHeader) {
    table.appendChild(createTableColumns(data, table, columns, options));
  }
  table.appendChild(addTableData(data, columns, showDetail, highlightGroups, options));
}

function createTableColumns(data, table, columns, options) {
  var thead = document.createElement('thead');

  if (data.length > 0) {
    var tr;
    tr = document.createElement('tr');
    Object.keys(columns).forEach(function (name) {
      var th = document.createElement('th');
      th.textContent = decamelize(name);
      tr.append(th);
    });
    thead.appendChild(tr);
  }

  if (sorting in options) {
    thead.addEventListener('click', function (e) {
      var t = e.target;

      if (!t.dataset.dir) { t.dataset.dir = 1; }
      else { t.dataset.dir *= -1; }
      // Remember the direction
      var tmpdir = t.dataset.dir;
      // Remove direction class fromn all headings
      for (var i = 0; i < tr.children.length; ++i) {
        var ch = tr.children[i];
        ch.classList.remove("ascending");
        ch.classList.remove("descending");
      }
      // Restore direction and set direction class for e.target
      t.dataset.dir = tmpdir;
      if (tmpdir > 0) {
        t.classList.add("ascending");
      }
      else if (tmpdir < 0) {
        t.classList.add("descending");
      }

      sortTableRows(table, t.cellIndex, t.dataset.dir);
    }, false);
  }
  return thead;
}

function firstColumn(tr, indent, colName, clazz) {
  var td = document.createElement('td');
  td.style.left = indentStyle(indent);
  td.style.position = 'relative';
  td.textContent = colName;
  if (clazz) {
    td.classList.add(clazz);
  }
  tr.appendChild(td)
}

function nonFirstColumn(tr, value, clazz, clazz2) {
  var td = document.createElement('td');
  td.style.textAlign = 'right';
  td.textContent = value;
  if (clazz) {
    td.classList.add(clazz);
  }
  if (clazz2) {
    td.classList.add(clazz2);
  }
  tr.appendChild(td)
}

function appendNumericSubtotal(tr, indent, data, columns, start, end, highlightGroups, options) {
  firstColumn(tr, indent, "Subtotal", "subtotal");
  var subs = {};
  var nums = {};

  Object.keys(columns).forEach(function (key, col) {
    if (col > 0) { // Already did firstColumn
      nums[key] = 0;
      subs[key] = "";
      for (var i = start; i < end; i++) {
        let value = data[i][key];
        if (isNaN(value) || value.length == 0) {
          subs[key] = "";
          break;
        }
        else {
          nums[key] += Number(value);
          subs[key] = nums[key].toFixed(decimalPlaces);
        }
      }
    }
  });

  var tdClass = {}
  if (highlight in options) {
    highlightGroups.forEach(function (group) {
      if (Number(subs[group[0]]) != 0) {
        var result = columnSubtract(subs[group[0]], subs[group[1]]);
        if ((result.comparison < 0 && doingExpense) || (result.comparison > 0 && !doingExpense)) {
          group.forEach(function (column) {
            tdClass[column] = 'highlight';
          })
        }
      }
    });
  }


  Object.keys(columns).forEach(function (key, col) {
    if (col > 0) { // Already did firstColumn; ignore blankzeros for subtotal
      nonFirstColumn(tr, subs[key], "subtotal",
        tdClass[key] ? tdClass[key] : null);
    }
  });
}

function columnSubtract(first, second) {
  let comparison = 0;
  let value = '';
  if (isNaN(second) || second.length == 0) {
    value = first;
  }
  else if (!isNaN(first) && first.length > 0) {
    let diff = Number(first) - Number(second);
    value = diff.toFixed(decimalPlaces);
    if (Number(value)) {
      comparison = Math.sign(diff);
    }
  }
  return { value, comparison };
}

function addTableData(data, columns, showDetail, highlightGroups, options) {
  var tbody = document.createElement('tbody');

  var frag = document.createDocumentFragment(),
    row, cell;

  let indent = -1;
  let rootIndent = 0;
  let newIndent = -1;
  let startRows = [];
  let priorFields = [];

  // ALWAYS start doing income
  doingExpense = false;

  for (var i = 0; i < data.length; i++) {
    var tr = document.createElement('tr');
    tr.src = data[i];

    let colNum = 0;

    var tdClass = {}
    if (highlight in options) {
      highlightGroups.forEach(function (group) {
        if (Number(data[i][group[0]]) != 0) {
          var result = columnSubtract(data[i][group[0]], data[i][group[1]]);
          if ((result.comparison < 0 && doingExpense) || (result.comparison > 0 && !doingExpense)) {
            group.forEach(function (column) {
              tdClass[column] = 'highlight';
            })
          }
        }
      });
    }

    Object.keys(columns).forEach(function (name) {
      let value = data[i][name];
      var td = document.createElement('td');
      if (tdClass[name]) {
        td.classList.add(tdClass[name]);
      }

      if (colNum == 0) {
        if (nested in options && typeof value == 'string') {
          if (value.toUpperCase().startsWith(expenseCategories.toUpperCase())) {
            // Doing expense now
            doingExpense = true;
          }
          // Indent nested fields
          let fields = value.split(':');
          newIndent = fields.length - 1;

          // Find index of first difference
          let firstDiff = 0;
          for (firstDiff = 0;
            firstDiff < fields.length
            && firstDiff < priorFields.length; ++firstDiff) {
            if (fields[firstDiff] !== priorFields[firstDiff]) {
              break;
            }
          }

          if (indent > firstDiff) {
            // Append Subtotal for each 'ended' indent
            while (indent > firstDiff) {
              // Subtotal only if more than one line
              if (subtotal in options && i - startRows[indent] > 1) {
                appendNumericSubtotal(tr, rootIndent + indent, data, columns,
                  startRows[indent], i, highlightGroups, options);
                frag.appendChild(tr);
                tr = document.createElement('tr');
              }
              --indent;
            }
            // And set current indent to first NOT different
            --indent;
          }

          if (newIndent > indent) {
            value = '';
            // remember start row and set value
            ++indent;
            value = fields[indent];
            // Prior row (heading) is the subtotal start row
            startRows[indent] = i - 1;
            while (newIndent > indent) {
              // This row is the subtotal start row (the heading is synthesized)
              startRows[indent] = i;
              firstColumn(tr, rootIndent + indent, fields[indent]);
              for (var col = 1; col < columns.length; ++col) {
                nonFirstColumn(tr, '');
              }
              ++indent;
              value = fields[indent];

              // Add missing header row
              frag.appendChild(tr);
              tr = document.createElement('tr');
            }
          }
          else {
            value = fields[newIndent];
          }
          priorFields = fields;
        }
        else {
          indent = 0;
        }

        // Set rootIndent AFTER appending Subtotal using prior indentation
        if (incomeExpense in options && typeof value == 'string'
          && !value.toUpperCase().startsWith(incomeCategories.toUpperCase())
          && !value.toUpperCase().startsWith(expenseCategories.toUpperCase())) {
          // Indent inside income/expense
          rootIndent = 1;
        }
        else {
          rootIndent = 0;
        }
        if (rootIndent + indent > 0) {
          // Apply visual indentation
          td.style.left = indentStyle(rootIndent + indent);
          td.style.position = 'relative';
        }
      }
      else {
        // All but first column align right
        td.style.textAlign = 'right';
      }
      if (blankZeros in options && value && value.trim() == '0') {
        // Blank zero values
        value = '';
      }
      td.dataset.propName = name;
      if (typeof (value) === 'object') {
        value = '[OBJECT]';
      }
      else if (!isNaN(value) && value.length > 0) {
        value = Number(value).toFixed(decimalPlaces);
      }
      else {
        var date = new Date(value)
        if (date.getTime() === date.getTime() && value.indexOf('-') > 0) {
          if (date.getFullYear() > 1) {
            value = date.toDateString();
          }
        }
      }

      td.textContent = value;
      tr.appendChild(td)
      ++colNum;
    });

    frag.appendChild(tr);
  }

  tbody.appendChild(frag);
  if (showDetail) {
    tbody.addEventListener('click', function (e) {
      showDetail(e.target.parentElement.src);
    }, false);
  }

  return tbody;
};

function sortTableRows(table, index, dir) {
  var switching = true;
  /*Make a loop that will continue until
  no switching has been done:*/
  while (switching) {
    //start by saying: no switching is done:
    switching = false;
    var rows = table.rows;

    for (var i = 1; i < (rows.length - 1); i++) {
      //start by saying there should be no switching:
      var shouldSwitch = false;
      /*Get the two elements you want to compare,
      one from current row and one from the next:*/
      var x = rows[i].cells[index].textContent;
      var y = rows[i + 1].cells[index].textContent;
      //check if the two rows should switch place:
      if ((dir > 0 && x.toLowerCase() > y.toLowerCase())
        || (dir < 0 && x.toLowerCase() < y.toLowerCase())) {
        //if so, mark as a switch and break the loop:
        shouldSwitch = true;
        break;
      }
    }
    if (shouldSwitch) {
      /*If a switch has been marked, make the switch
      and mark that a switch has been done:*/
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
    }
  }
};

  </script>
  <style>
:root {
  --body-background: white;
  --border-color: black;
  --table-border-color: #ddd;
  --even-background: #ddd;
  --field-background: #dcdcdc;
  --group-background: #eee;
  --contained-background: #fcfcfc;
  --thead-background: linear-gradient(#bbb, #ddd);
}


table {
  font-family: arial, sans-serif;
  width: 100%;
  border-right: 1px solid var(--table-border-color);
  background-color: var(--body-background);
}

td,
th {
  border-left: 1px solid var(--table-border-color);
  border-top: 1px solid var(--table-border-color);
  border-bottom: 0px solid var(--table-border-color);

  text-align: left;
  padding: 8px;
  min-height: 20px;
  max-width: 20%;
}

thead {
  background: var(--thead-background);
  font-weight: 300;
  letter-spacing: 1px;
  cursor: pointer;
}

.subtotal {
  border-top: 2px solid black;
  border-bottom: 0px solid var(--table-border-color);
}

.descending::after {
  content: " \290A";
}

.ascending::after {
  content: " \290B";
}


th {
  text-align: center;
}

tr:nth-child(even) {
  background-color: var(--even-background);
}

body {
  padding: 8px;
  background-color: var(--body-background);
}

form {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 75%;
  transform: translate(-50%, -50%);
}

fieldset {
  padding: 5px;
  /*  color: white;*/
}

fieldset label {
  display: inline-block;
  width: 100px;
}

fieldset input {
  padding: 1px;
  margin: 4px;
  font-weight: bold;
}

fieldset {
  width: 100%;
  height: 100%;
  background-color: var(--field-background);
  z-index: 2;
  overflow-y: scroll;
}

textarea{
  width: 80%;
  height: 200px;
}

.highlight {
  background-color: cornsilk;
  font-weight: bold;
}

.error {
  color: red;
}

.input-span {
  display: inline-block;
  width: fit-content;
  border: 1px solid;
  padding: 2px;
  margin: 3px;
  border-radius: 4px;
}

.group {
  background-color: var(--group-background);
  border: 2px solid var(--border-color);
  display:inline-flex;
  border-radius: 4px;
  padding: 4px;
  margin: 4px;
}

.container {
  display: inline-flex;
  flex-wrap: wrap;
}

.contained {
  background-color: var(--contained-background);
  padding: 4px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  float: left;
  width: 120px;
  margin: 4px;
}

.containedbtn {
  padding: 4px;
  border-radius: 5px;
  float: left;
  margin: 4px;
}

/* styling of the tooltip display */
p#tooltip-text {
  display: none;
  position: absolute;
  top: 60px;
  z-index: 1;
  background: cornsilk;
  padding: 8px;
  font-size: 1rem;
  color: black;
  border-radius: 2px;
  animation: fadeIn 0.6s;
}

/* optional styling to add a "wedge" to the tooltip */
p#tooltip-text:before {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -8px;
  border: 8px solid transparent;
  border-top: 8px solid black;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}  </style>
</head>

<body>
  <div id="config">
    <h1><span id="title"></span>
      <span id="id-object"></span>
    </h1>

    <div id="config">
      <span class="input-span">
        This Month <input type="file" id="id-thismonth" style="width:303px;" accept="text/csv"
          onclick="type=''; type='file';" onchange="readFile('id-thismonth', false)">
      </span>
      <span class="input-span">
        Prior Month <input type="file" id="id-nextmonth" accept="text/csv" onclick="type=''; type='file';"
          style="width:300px;" onchange="readFile('id-nextmonth', true)">
      </span>
      <span class="input-span">
        Budget Row <input type="button" onclick="showRowOrder()" value="Order" /> <input type="file" id="id-rows"
          accept="text/plain" onclick="type=''; type='file';" style="width:244px;" onchange="readRowOrder('id-rows')">
      </span>
      <span class='input-span'> Page Heading
        <input id="pageheading" size="60" type="text" />
      </span>
      <span class="input-span">
        <label for="decimal-places"> Decimal Places</label>
        <select name="decimal-places" id="decimal-places">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
        </select>

        <label for="printed-on"> Print Date</label>
        <input id="printed-on" type="checkbox" checked>

        <input type="button" onclick="printHiding('config')" value="Hide Configuration and Print" />
      </span>
    </div>
    <p id="tooltip-text">The tooltip text.</p>
    <div class="group ">
      <div class="containedbtn">Columns
        <br><button onclick="setAllOptions(contentColumns[combinedName], 'col-', true);">Select:All</button>
        <br><button onclick="setAllOptions(contentColumns[combinedName], 'col-', false);">Deselect:All</button>
      </div>
      <div id="id-columns" class="container"></div>
    </div><br>
    <div class="group ">
      <div class="containedbtn">Format
        <br><button onclick="setAllOptions(tableOptions, 'fmt-', true);">Select:All</button>
        <br><button onclick="setAllOptions(tableOptions, 'fmt-', false);">Deselect:All</button>
      </div>
      <div id="id-format" class="container"></div>
    </div>

    <P><input type="button" onclick="showData()" value="(re)Display)">
      <span id="revision" style="float:right"></span>
    </P>
  </div>

  <form id="id-data-form" action="">
    <fieldset id="id-data-form">
      <div id="dataFormId"></div>
      <input style="padding: 6px; float: right" type="button" value="Close" onclick="hideDataform()">
    </fieldset>
  </form>
  <div id="id-error" class="error"></div>
  <div id="id-data"></div>
</body>

</html>